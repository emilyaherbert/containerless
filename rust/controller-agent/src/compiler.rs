//! The compiler uses `cargo build` in the `/src` directory, so it must
//! run as a single threaded task.
use crate::common::*;
use super::trace_compiler;
use duct::cmd;
use futures::channel::mpsc;
use k8s;
use quote::__private::TokenStream;
use quote::quote;
use syn::Ident;
use proc_macro2::Span;

enum Message {
    Compile { name: String, code: Bytes },
    Shutdown,
}

#[derive(Clone)]
pub struct CompilerHandle {
    send_message: mpsc::Sender<Message>,
}

fn gen_function_table_entry(name: &str) -> TokenStream {
    let q_id = Ident::new(&format!("function_{}", name), Span::call_site());
    return quote! {
        ht.insert(#name, #q_id::containerless);
    };
}

fn gen_function_mod(name: &str) -> TokenStream {
    let q_id = Ident::new(&format!("function_{}", name), Span::call_site());
    return quote! {
        mod  #q_id;
    };
}

fn gen_function_table_file(table: &[String]) -> TokenStream {
    let q_mods: Vec<_> = table.iter().map(|x| gen_function_mod(x)).collect();
    let q_inserts: Vec<_> = table.iter().map(|x| gen_function_table_entry(x)).collect();
    return quote! {
        // This file is generated by the compiler in controller-agent.
        use super::trace_runtime::Containerless;
        use std::collections::HashMap;
        #(#q_mods)*

        pub fn init() -> HashMap<&'static str, Containerless> {
            let mut ht: HashMap<&'static str, Containerless> = HashMap::new();
            #(#q_inserts)*
            return ht;
        }
    };
}

async fn update_dispatcher_deployment(k8s: &k8s::Client, version: usize) -> Result<(), kube::Error> {
    use k8s::*;
    let deployment = DeploymentBuilder::new()
        .metadata(
            ObjectMetaBuilder::new()
                .name("dispatcher")
                .namespace(NAMESPACE)
                .build(),
        )
        .spec(
            DeploymentSpecBuilder::new()
                .replicas(1)
                .selector("app", "dispatcher")
                .template(
                    PodTemplateSpecBuilder::new()
                        .metadata(ObjectMetaBuilder::new().label("app", "dispatcher").build())
                        .spec(
                            PodSpecBuilder::new()
                                .container(ContainerBuilder::new()
                                    .name("dispatcher")
                                    .image("localhost:32000/dispatcher")
                                    .always_pull()
                                    .expose_port("http", 8080)
                                    .env("RUST_LOG", "error,dispatcher=debug,dispatcher-launcher=info")
                                    .env("Version", format!("V{}", version))
                                    .http_readiness_probe(5, "/readinessProbe/", 8080)
                                    .build())
                                .build(),
                        )
                        .build(),
                )
                .build(),
        )
        .build();
    return k8s.patch_deployment(deployment).await;
}

async fn compiler_task(mut recv_message: mpsc::Receiver<Message>) {
    let k8s = k8s::Client::new(NAMESPACE)
        .await
        .expect("creating k8s::Client");
    let mut next_version = 1;
    let mut available_functions = Vec::new();

    while let Some(message) = recv_message.next().await {
        match message {
            Message::Compile { name, code } => {
                info!(target: "controller", "compiler task received trace for {}", &name);
                next_version = next_version + 1;
                let trace_compile_err = trace_compiler::compile(
                    name.clone(), 
                    &format!("/src/dispatcher-agent/src/decontainerized_functions/function_{}.rs", &name),
                    &String::from_utf8_lossy(&code));
                if let Err(err) = trace_compile_err {
                    error!(target: "controller", "error compiling trace for {}: {}", &name, err);
                    continue;
                }

                available_functions.push(name);

                std::fs::write(
                    "/src/dispatcher-agent/src/decontainerized_functions/mod.rs", 
                    format!("{}", gen_function_table_file(&available_functions)))
                    .expect("cannot write function table file");

                cmd!("cargo", "build").dir("/src/dispatcher-agent")
                    .run()
                    .expect("cargo build failed");

                // TODO(arjun): If several traces are queued up, we should batch
                // them together before updating the deployment.
                update_dispatcher_deployment(&k8s, next_version).await.expect("patching dispatcher deployment");
                info!(target: "controller", "Patched dispatcher deployment");
            }
            Message::Shutdown => {
                info!(target: "controller", "ending compiler task (received shutdown message)");
                return;
            }
        }
    }

    info!(target: "controller", "ending compiler task (all senders closed)");
    return;
}

pub fn start_compiler_task() -> CompilerHandle {
    let (send, recv) = mpsc::channel(1);
    task::spawn(compiler_task(recv));
    return CompilerHandle { send_message: send };
}

impl CompilerHandle {
    async fn compile_internal(mut self, name: String, code: Bytes) {
        if let Err(_err) = self
            .send_message
            .send(Message::Compile { name, code })
            .await
        {
            error!(target: "compiler", "could not send a compile message (compiler task is shutdown)");
        }
    }

    pub fn compile(&self, name: String, code: Bytes) {
        let compiler_handle = self.clone();
        task::spawn(compiler_handle.compile_internal(name, code));
    }

    pub async fn shutdown(&mut self) {
        if let Err(_err) = self.send_message.send(Message::Shutdown).await {
            error!(target: "compiler", "could not send a shutdown message (compiler task is shutdown)");
        }
    }
}
