//! The compiler uses `cargo build` in the `/src` directory, so it must
//! run as a single threaded task.
use super::trace_compiler;
use crate::common::*;
use futures::channel::mpsc;
use k8s;
use proc_macro2::Span;
use quote::__private::TokenStream;
use quote::quote;
use std::fs;
use std::io::{self, Write};
use std::process::Stdio;
use syn::Ident;
use tokio::process::Command;
use tokio::task;

enum Message {
    Compile {
        name: String,
        code: Bytes,
    },
    Shutdown {
        done: oneshot::Sender<()>,
    },
    RecompileDispatcher {
        started_compiling: oneshot::Sender<()>,
    },
    ResetDispatcher {
        started_compiling: oneshot::Sender<()>,
    },
}

#[derive(PartialEq)]
enum CompileStatus {
    Compiling,
    Compiled,
    Error,
}

pub struct Compiler {
    send_message: mpsc::Sender<Message>,
    is_compiling_now: AtomicBool,
}

fn gen_function_table_entry(name: &str) -> TokenStream {
    let q_id = Ident::new(&format!("function_{}", name), Span::call_site());
    return quote! {
        ht.insert(#name, #q_id::containerless);
    };
}

fn gen_function_mod(name: &str) -> TokenStream {
    let q_id = Ident::new(&format!("function_{}", name), Span::call_site());
    return quote! {
        mod  #q_id;
    };
}

fn gen_function_table_file(table: &[String]) -> TokenStream {
    let q_mods: Vec<_> = table.iter().map(|x| gen_function_mod(x)).collect();
    let q_inserts: Vec<_> = table.iter().map(|x| gen_function_table_entry(x)).collect();
    return quote! {
        // This file is generated by the compiler in controller-agent.
        use dispatcher_agent_lib::trace_runtime::Containerless;
        use std::collections::HashMap;
        #(#q_mods)*

        pub fn init() -> HashMap<&'static str, Containerless> {
            let mut ht: HashMap<&'static str, Containerless> = HashMap::new();
            #(#q_inserts)*
            return ht;
        }
    };
}

pub fn dispatcher_deployment_spec(version: usize) -> k8s::Deployment {
    use k8s::*;
    return DeploymentBuilder::new()
        .metadata(
            ObjectMetaBuilder::new()
                .name("dispatcher")
                .namespace(NAMESPACE)
                .build(),
        )
        .spec(
            DeploymentSpecBuilder::new()
                .replicas(1)
                .selector("app", "dispatcher")
                .template(
                    PodTemplateSpecBuilder::new()
                        .metadata(ObjectMetaBuilder::new().label("app", "dispatcher").build())
                        .spec(
                            PodSpecBuilder::new()
                                .container(
                                    ContainerBuilder::new()
                                        .name("dispatcher")
                                        .image("localhost:32000/dispatcher")
                                        .expose_port("http", 8080)
                                        .pull_if_not_present()
                                        .env(
                                            "LOG_RSYSLOG_ADDR",
                                            std::env::var("LOG_RSYSLOG_ADDR").unwrap(),
                                        )
                                        .env("LOG_LEVEL", std::env::var("LOG_LEVEL").unwrap())
                                        .env("Version", format!("V{}", version))
                                        .http_readiness_probe(1, "/readinessProbe/", 8080)
                                        .build(),
                                )
                                .build(),
                        )
                        .build(),
                )
                .build(),
        )
        .build();
}

fn generate_decontainerized_functions_mod(known_functions: &HashMap<String, CompileStatus>) {
    let available_functions = known_functions
        .iter()
        .filter(|(_, v)| **v != CompileStatus::Error)
        .map(|(k, _)| k.clone())
        .collect::<Vec<_>>();

    std::fs::write(
        format!(
            "{}/dispatcher-agent/src/decontainerized_functions/mod.rs",
            ROOT.as_str()
        ),
        format!("{}", gen_function_table_file(&available_functions)),
    )
    .expect("cannot write function table file");
}

async fn compiler_task(compiler: Arc<Compiler>, mut recv_message: mpsc::Receiver<Message>) {
    let k8s = k8s::Client::from_kubeconfig_file(NAMESPACE)
        .await
        .expect("creating k8s::Client");
    let mut next_version = 1;

    let mut known_functions: HashMap<String, CompileStatus> = HashMap::new();

    while let Some(message) = recv_message.next().await {
        match message {
            Message::RecompileDispatcher { started_compiling } => {
                if compiler.cargo_build(Some(started_compiling)).await == false {
                    error!(target: "controller", "The code for dispatcher-agent is in a broken state. The system may not work.");
                    continue;
                }
                next_version = next_version + 1;
                crate::graceful_sigterm::delete_dynamic_resources(&k8s, false)
                    .await
                    .expect("deleting dynamically created resources");
                k8s.patch_deployment(dispatcher_deployment_spec(next_version))
                    .await
                    .expect("patching dispatcher deployment");
                info!(target: "controller", "Patched dispatcher deployment");
            }
            Message::ResetDispatcher { started_compiling } => {
                info!(target: "controller", "clearing Controller state");
                known_functions.clear();
                generate_decontainerized_functions_mod(&known_functions);
                if compiler.cargo_build(Some(started_compiling)).await == false {
                    error!(target: "controller", "The code for dispatcher-agent is in a broken state. The system may not work.");
                    continue;
                }
                next_version = next_version + 1;
                crate::graceful_sigterm::delete_dynamic_resources(&k8s, false)
                    .await
                    .expect("deleting dynamically created resources");
                k8s.patch_deployment(dispatcher_deployment_spec(next_version))
                    .await
                    .expect("patching dispatcher deployment");
                info!(target: "controller", "Patched dispatcher deployment");
            }
            Message::Compile { name, code } => {
                info!(target: "controller", "compiler task received trace for {}", &name);
                next_version = next_version + 1;
                fs::write(
                    format!(
                        "{}/dispatcher-agent/src/decontainerized_functions/function_{}.json",
                        ROOT.as_str(),
                        &name
                    ),
                    &code,
                )
                .expect("failed to create trace (JSON) file");
                let trace_compile_err = trace_compiler::compile(
                    name.clone(),
                    &format!(
                        "{}/dispatcher-agent/src/decontainerized_functions/function_{}.rs",
                        ROOT.as_str(),
                        &name
                    ),
                    &String::from_utf8_lossy(&code),
                );
                if let Err(err) = trace_compile_err {
                    known_functions.insert(name.clone(), CompileStatus::Error);
                    error!(target: "controller", "error compiling trace for {}: {}", &name, err);
                    continue;
                }

                known_functions.insert(name.clone(), CompileStatus::Compiling);
                generate_decontainerized_functions_mod(&known_functions);

                if compiler.cargo_build(None).await == false {
                    known_functions.insert(name.clone(), CompileStatus::Error);
                    generate_decontainerized_functions_mod(&known_functions);
                    continue;
                }
                known_functions.insert(name.clone(), CompileStatus::Compiled);

                // TODO(arjun): If several traces are queued up, we should batch
                // them together before updating the deployment.
                k8s.patch_deployment(dispatcher_deployment_spec(next_version))
                    .await
                    .expect("patching dispatcher deployment");
                info!(target: "controller", "Patched dispatcher deployment");
            }
            Message::Shutdown { done } => {
                crate::graceful_sigterm::delete_dynamic_resources(&k8s, true)
                    .await
                    .expect("deleting dynamically created resources");
                info!(target: "controller", "ending compiler task (received shutdown message)");
                done.send(()).expect("sending done");
                return;
            }
        }
    }

    info!(target: "controller", "ending compiler task (all senders closed)");
    return;
}

impl Compiler {
    pub fn new() -> Arc<Self> {
        let (send_message, recv_message) = mpsc::channel(1);
        let is_compiling_now = AtomicBool::new(false);
        let compiler = Arc::new(Compiler {
            send_message,
            is_compiling_now,
        });
        task::spawn(compiler_task(compiler.clone(), recv_message));
        return compiler;
    }

    pub async fn cargo_build(&self, started_compiling: Option<oneshot::Sender<()>>) -> bool {
        let was_compiling = self.is_compiling_now.swap(true, SeqCst);
        if was_compiling {
            panic!("cargo was already running. This should not happen");
        }
        if let Some(sender) = started_compiling {
            sender
                .send(())
                .expect("could not send started_compiling message");
        }
        info!(target: "controller", "Running cargo build on dispatcher-agent. Output is suppressed unless an error occurs.");
        let cargo_result = Command::new("cargo")
            .arg("build")
            .current_dir(&format!("{}/dispatcher-agent", ROOT.as_str()))
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .output()
            .await
            .expect("waiting for cargo to complete");
        self.is_compiling_now.store(false, SeqCst);
        if cargo_result.status.success() == false {
            io::stderr().write(&cargo_result.stderr).unwrap();
            io::stdout().write(&cargo_result.stdout).unwrap();
            error!(target: "dispatcher", "cargo build failed");
            return false;
        }
        return true;
    }

    fn send_message_non_blocking(&self, message: Message) {
        let mut send_message = self.send_message.clone();
        task::spawn(async move {
            send_message
                .send(message)
                .await
                .expect("compiler task shutdown")
        });
    }

    pub fn compile(&self, name: String, code: Bytes) {
        self.send_message_non_blocking(Message::Compile { name, code });
    }

    pub async fn shutdown(&self) {
        let (send, recv) = oneshot::channel();
        let mut send_message = self.send_message.clone();
        send_message
            .send(Message::Shutdown { done: send })
            .await
            .expect("compiler task shutdown");
        return recv.await.expect("compiler task shutdown");
    }

    pub fn ok_if_not_compiling(&self) -> http::StatusCode {
        if self.is_compiling_now.load(SeqCst) == false {
            return http::StatusCode::OK;
        } else {
            return http::StatusCode::SERVICE_UNAVAILABLE;
        }
    }

    /// recompile_dispatcher blocks until "cargo build" starts running.
    pub async fn recompile_dispatcher(&self) -> http::StatusCode {
        let (send, recv) = oneshot::channel();
        self.send_message_non_blocking(Message::RecompileDispatcher {
            started_compiling: send,
        });
        recv.await.expect("compiler task shutdown");
        return http::StatusCode::OK;
    }

    pub async fn reset_dispatcher(&self) -> http::StatusCode {
        let (send, recv) = oneshot::channel();
        self.send_message_non_blocking(Message::ResetDispatcher {
            started_compiling: send,
        });
        recv.await.expect("compiler task shutdown");
        return http::StatusCode::OK;
    }
}
